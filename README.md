# ITMO_project_sem1

Проект подготовлен студентами потока 1.4:
- Серкин Павел Александрович
- Лысенко Мирослав Андреевич
- Антонюк Марьяна Кирилловна
- Павелионес Константин Александрович

# Описание проекта

## Цель проекта
Данный проект - визуализатор продаж. Его цель - обработать csv файл с данными о продажах и вывести желаемый пользователем результат.

## Структура проекта
Программа состоит из трех модулей: main.py, process.py, manager.py. Также для тестирования добавлены файлы с данными: Data 1.csv и Data 2.csv

## Функционал программы
Программа предоставляет пользователю выбор из нескольких видов анализа данных. 
- Подсчет выручки и прибыли за определнный период.
- Распределение ключевых характеристик товаров по категориям.
- Сводная аналитика по движению товаров.
- Информация о самых продаваемых товарах

## Запуск и работа с программой
Программа запускается при инициализации файла main.py. Программа завершается, когда после выполнения очередной функции пользователь напишет в терминал "нет".

Подробнее про структуру и работу каждой функции: https://docs.google.com/document/d/1L2K6SjDaU_HgC6lo8klSB3Ucv0bbCEJ1/edit?usp=sharing&ouid=113936519284966201368&rtpof=true&sd=true.

Видео от разработчиков с объяснением функционала: https://disk.yandex.ru/d/CvOUqtVdif813w

# Индивидуальные правки (Лысенко Мирослав Андреевич 504458)
## В рамках индивидуальной части проекта были реализованы дополнительные функции, направленные на улучшение удобства работы пользователя с программой, без нарушения общей архитектуры проекта.
### Так же прошу обратить Ваше внимание на то, что для Вашего удобства в коде все внесенные правки закомментированы в виде "Правка:"
### Ниже подробно описаны все добавленные правки.

## Правка №1: Запоминание последнего использованного файла. 
Реализовано в manager.py 
#### Были реализованы такие функции, как:
- save_last_file(file_path) 
- load_last_file()
##### Функция save_last_file вызывается после успешной загрузки и обработки данных. Она сохраняет путь к CSV-файлу в отдельный текстовый файл, используя стандартные средства работы с файлами в Python.
##### Функция load_last_file вызывается при запуске программы. Она проверяет, существует ли файл с сохранённым путём, и если да — считывает его и возвращает строку с путём к последнему файлу.
##### В функции get_user_request эта логика используется следующим образом:
- сначала проверяется наличие сохранённого пути;
- если он найден, пользователю предлагается использовать его;
- в зависимости от ответа пользователя либо используется сохранённый путь, либо запрашивается новый.
#### Эти функции сохраняют путь к последнему успешно загруженному CSV-файлу в отдельный служебный файл и позволяют загрузить его при следующем запуске программы.
#### Без этого пользователю каждый раз приходилось вручную вводить путь к CSV-файлу, даже если он работает с одним и тем же набором данных.
#### Теперь при запуске программа: 
1) Предлагает использовать последний файл
2) Избавляет пользователя от повторого ввода
3) Ускоряет работу с программой
#### Для пользователя это снизит количество однотипных действий, поможет быстрее начать работу. Кроме того, благодаря этому программа стала более "умной" и дружелюбной к пользователю.

## Правка №2: Мини-отчет о данных после загрузки
#### Реализовано в manager.py

##### Эта правка реализована внутри функции get_user_request сразу после выполнения: 
- load_sales_data
- preprocess_data

##### После того как данные успешно загружены и очищены, из датафрейма data_clean извлекается базовая информация:
- количество строк (len(data_clean))
- минимальная и максимальная дата через обращение к столбцу "Дата"
- уникальные значения районов и отделов с помощью метода .unique()

#### После успешной загрузки и очистки данных пользователю выводится краткая информация:
1) количество строк в данных
2) период дат (минимальная и максимальная дата)
3) список доступных районов
4) список доступных отделов товаров
#### Без этой информации пользователь не понимает:
1) загрузился ли файл корректно
2) какие данные вообще есть внутри
3) какие значения можно использовать дальше (например, для фильтрации)
#### Теперь же пользователь сразу видит, с чем он работает, снижается вероятность ошибок при дальнейшем вводе, повышается прозрачность работы программы.

## Правка №3: Фильтрация данных по району и отделу
#### Реализовано в manager.py (менялась часть кода другого участника проекта)
##### Фильтрация реализована через уже существующую функцию apply_filters, которая принимает:
- датафрейм data_clean;
- параметры district и department.
##### В функции get_user_request добавлен пользовательский ввод:
- пользователь может указать район и/или отдел;
- если поле оставлено пустым, соответствующий фильтр не применяется.
##### Передача параметров в apply_filters организована так, что:
- если значение не введено, в функцию передаётся None;
- внутри apply_filters фильтрация применяется только по тем параметрам, которые заданы.
##### Таким образом:
- используется уже существующая функция проекта;
- логика фильтрации централизована;
- данные фильтруются один раз перед меню, и дальше вся аналитика работает с уже отфильтрованным датафреймом.
#### Пользователю предлагается:
1) ввести район магазина
2) ввести отдел товара
3) либо оставить поля пустыми, чтобы работать со всеми данными
#### Фильтрация применяется один раз перед началом аналитики, и все последующие действия выполняются уже над отфильтрованным набором данных.

### В базовой версии программа всегда работала со всем массивом данных, что было неудобно при большом объёме, а также не позволяло анализировать конкретные сегменты.
#### Благодаря этому у пользователей появилось:
1) возможность анализировать конкретный район или отдел
2) более точные графики и результаты
3) гибкость без усложнения интерфейса

## Правка №4 Сохранение результатов анализа (графиков)
#### Реализовано в manager.py (менялась часть кода другого участника)
##### Данная правка реализована внутри функций визуализации.
##### После построения графика с помощью matplotlib, но до вызова plt.show(), добавлена логика:
- проверки существования папки reports
- создания папки при необходимости
- запроса у пользователя, хочет ли он сохранить график
- сохранения изображения через plt.savefig
##### Сохранение вынесено именно в функцию визуализации, так как:
- только в этот момент график уже полностью сформирован
- функция уже отвечает за отображение результата анализа
###### Использование plt.savefig позволяет сохранить точную копию графика, который видит пользователь на экране.
#### После построения графиков программа:
1) предлагает сохранить результат
2) автоматически создаёт папку reports, если её нет
3) сохраняет график в формате .png

### Ранее пользователь мог только посмотреть график на экране. Чтобы сохранить результат, приходилось делать скриншоты.
#### Теперь:
1) сохранение результатов в один клик
2) удобство использования вне программы (например, для отчётов)
3) программа становится ближе к реальному аналитическому инструменту

## Связь с архитектурой проекта
#### Все внесенные индивидуальные правки:
1) Не нарушают существующую структуру проекта
2) Встроенны в уже существующие модули (manager.py)
3) Не дублируют функциональность
4) Используют уже имеющиеся данные и функции.

## Результат внесенных правок
#### В результате внесенных правок программа:
1) Стала гораздо удобнее для пользователя
2) Уменьшила количество рутинных действий
3) Стала более наглядной и интерактивной
4) Сохранила простоту использования
   
### Таким образом, все внесенные правки носят практический характер, направлены на улучшение пользовательского опыта и логично вписываются в существующую архитектуру проекта. 
